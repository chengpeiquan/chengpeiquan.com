{
  "title": "Vue3.0最新动态：script-setup定稿 部分实验性API将弃用",
  "desc": "从尤大的Twitter上获取到了最新的开发进展，期待已久的script-setup组件模式终于定稿，不再是实验性功能了，当然对比之前的实验性阶段也有一些新的变化，包括一些API被弃用，同时也有新的API补充进来代替原有的功能。",
  "keywords": "script setup,vue 3.0 script setup,vue3 script setup,script setup prop,script setup emit,defineProps,vue 3.0 defineProps,vue defineProps,vue3 defineProps,prop defineProps,setup defineProps,defineEmits,vue 3.0 defineEmits,vue defineEmits,vue3 defineEmits,emit defineEmits,setup defineEmits,useAttrs,vue 3.0 useAttrs,vue useAttrs,vue3 useAttrs,setup useAttrs,useSlots,vue 3.0 useSlots,vue useSlots,vue3 useSlots,setup useSlots",
  "date": "2021-07-05 21:15:13",
  "cover": "http://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage//img/2021/07/20210705181949.jpg?x-oss-process=image/interlace,1",
  "categories": [
    "tech"
  ],
  "repo": "https://github.com/chengpeiquan/learning-vue3",
  "id": "vue3-script-setup-finalization",
  "type": "article",
  "author": {
    "name": "chengpeiquan",
    "email": "chengpeiquan@chengpeiquan.com",
    "link": "https://chengpeiquan.com"
  },
  "shortDate": "2021-07-05",
  "content": "<p>[[toc]]</p>\n<p>今天一早收到一条 issue <a href=\"https://github.com/chengpeiquan/learning-vue3/issues/107\">#107</a> ，有开发者在咨询我 Vue 3.0 script setup 的新 API 怎么用。</p>\n<p>最近一段时间挺忙，加上官方的开发动态也不是很多新东西，所以关注的比较少，看了一下 release 记录，发现最新的 2 个小版本对这个新特性改动还算蛮大的，之前的用法都调整了不少。</p>\n<p>今天距离上一次发文讨论 script-setup 新特性已经有 4 个多月了（<a href=\"https://chengpeiquan.com/article/vue3-script-setup.html\">回顾上一篇</a>），虽然截止至 7 月 2 日的 <code>3.1.4</code> 版本，script-setup 还是处于实验性阶段，但在同一天，尤大在 <a href=\"https://twitter.com/youyuxi/status/1410744671848910851\">twitter</a> 上发布了一条推文，预告了它将会在 <code>3.2.0</code> 版本脱离实验状态，正式进入 Vue 3.0 的队伍。</p>\n<p>先简单梳理一下本次定稿下来的一些调整：</p>\n<h2>useContext API 被弃用</h2>\n<p>在原先，可以通过该 API 来获取组件的上下文信息，包含了 attrs 、slots 、emit、expose 等父子组件通信数据和方法。</p>\n<pre><code class=\"language-ts\">// 导入 useContext 组件\nimport { useContext } from 'vue'\n\n// 获取 context\nconst ctx = useContext()\n</code></pre>\n<p>该 API 将在 3.2 版本之后删除，context 里面的数据，会用新的 useSlots 和 useAttrs API 来代替。</p>\n<h2>新增 useSlots API 和 useAttrs API</h2>\n<p>在 useContext API 被删除后，原先的上下文数据，将由这两个新 API 获取到。</p>\n<h3>useAttrs</h3>\n<p>顾名思义， useAttrs 可以是用来获取 attrs 数据的（也就是非 props 的属性值）。</p>\n<pre><code class=\"language-ts\">// 导入 useAttrs 组件\nimport { useAttrs } from 'vue'\n\n// 获取 attrs\nconst attrs = useAttrs()\n\n// attrs是个对象，和 props 一样，需要通过 key 来得到对应的单个 attr\nconsole.log(attrs.msg);\n</code></pre>\n<p>如果当前组件里没有将某个属性指定为 props，那么父组件绑定下来的属性值，都会进入到 attrs 里，通过这个新 API 来拿到。</p>\n<h3>useSlots</h3>\n<p>同样，通过 API 的命名也能了解它是用来获取插槽数据的。</p>\n<p>但这个 API 对大部分同学来说应该用的比较少，因为大部分 Vue 开发者应该都是用的 SFC 模式（单组件），插槽可以直接在 template 里使用 <code>&lt;slot /&gt;</code> 标签渲染。</p>\n<p>所以，我个人觉得这个 API 的目标用户是面向 JSX / TSX 的开发者，简单的用法参考如下：</p>\n<p>父组件，可以传入默认插槽和命名插槽：</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- 子组件 --&gt;\n  &lt;ChildTSX&gt;\n    &lt;!-- 默认插槽 --&gt;\n    &lt;p&gt;I am a default slot from TSX.&lt;/p&gt;\n    &lt;!-- 默认插槽 --&gt;\n\n    &lt;!-- 命名插槽 --&gt;\n    &lt;template #msg&gt;\n      &lt;p&gt;I am a msg slot from TSX.&lt;/p&gt;\n    &lt;/template&gt;\n    &lt;!-- 命名插槽 --&gt;\n  &lt;/ChildTSX&gt;\n  &lt;!-- 子组件 --&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport ChildTSX from '@cp/context/Child.tsx'\n&lt;/script&gt;\n</code></pre>\n<p>那么在 JSX / TSX 的子组件，通过 useSlots 来获取父组件传进来的 slots 数据进行渲染：</p>\n<pre><code class=\"language-ts\">import { defineComponent, useSlots } from 'vue'\n\nconst ChildTSX = defineComponent({\n  setup() {\n    // 获取插槽数据\n    const slots = useSlots()\n\n    // 渲染组件\n    return () =&gt; (\n      &lt;div&gt;\n        // 渲染默认插槽\n        &lt;p&gt;{ slots.default ? slots.default() : '' }&lt;/p&gt;\n\n        // 渲染命名插槽\n        &lt;p&gt;{ slots.msg ? slots.msg() : '' }&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  },\n})\n\nexport default ChildTSX\n</code></pre>\n<h2>新增 defineExpose API</h2>\n<p>在标准组件写法里，子组件的数据都是默认隐式暴露给父组件的，但在 script-setup 模式下，所有数据只是默认 return 给 template 使用，不会暴露到组件外，所以父组件是无法直接通过挂载 ref 变量获取子组件的数据。</p>\n<p>如果要调用子组件的数据，需要先在子组件显示的暴露出来，才能够正确的拿到，这个操作，就是由 expose 来完成。</p>\n<p>expose 也是 context 的一个组件成员，原来的用法，是从 useContext 里导出：</p>\n<pre><code class=\"language-ts\">// 导入 useContext 组件\nimport { useContext } from 'vue'\n\n// 启用expose组件\nconst { expose } = useContext();\n\n// 定义一个想提供给父组件拿到的数据\nconst msg: string = 'Hello World!';\n\n// 显示暴露的数据，才可以在父组件拿到\nexpose({\n  msg\n});\n</code></pre>\n<p>由于 useContext 会在未来版本里移除，所以新增了 defineExpose API 来实现 expose 的功能。</p>\n<p>新的 API 用法：</p>\n<pre><code class=\"language-ts\">// 导入 defineExpose 组件\nimport { defineExpose } from 'vue'\n\n// 定义数据\nconst msg: string = 'Hello World!'\n\n// 暴露给父组件\ndefineExpose({\n  msg\n})\n</code></pre>\n<p>父组件就可以通过 ref API 去拿到子组件暴露出来的 <code>msg</code> 数据了。</p>\n<h2>改名 defineEmits API</h2>\n<p>使用 defineEmits 取待原来的 defineEmit API ，也就是改名了。</p>\n<p>好吧，我之前的文章还特地强调了 defineProps 是复数结尾，带有 s，而 defineEmit 没有，如今，都统一了，都是复数形式。</p>\n<p>从尤大的更新说明里看，大约只是一个 typo 更新，对比原来的 defineEmit ，目的是使用新的 defineEmits 与标准组件的 emits 命名上更为接近，和 defineProps 也更统一。</p>\n<p>╮(╯▽╰)╭ 所以用法方面和原来是没什么区别的：</p>\n<pre><code class=\"language-ts\">// 导入 defineEmits 组件\nimport { defineEmits } from 'vue'\n\n// 获取 emit\nconst emit = defineEmits(['say-hi', 'change-name']);\n\n// 调用 emit 打招呼\nemit('say-hi', 'Hello!');\n\n// 调用 emit 改名\nemit('change-name', 'Tom');\n</code></pre>\n<h2>新增 withDefaults API</h2>\n<p>说完 emits，经常与之同时出现的 props 也有一些变化，本次是带来了一个全新的 withDefaults API，用于辅助 defineProps 来指定 prop 的默认值。</p>\n<p>在以前的文章我有提及到，当你用 TypeScript 编程时，defineProps 有两种类型指定方式：</p>\n<ol>\n<li>通过构造函数进行检查（传统方法）</li>\n</ol>\n<p>第一种方式是使用 JavaScript 原生构造函数进行类型规定，使用这种方法时，如果你要限制 props 的类型和默认值，需要通过一个 “对象” 入参来传递给 defineProps，比如：</p>\n<pre><code class=\"language-ts\">// 导入 defineProps 组件\nimport { defineProps } from 'vue'\n\n// 定义 props\ndefineProps({\n  name: {\n    type: String,\n    required: false,\n    default: 'Petter',\n  },\n  userInfo: Object,\n  tags: Array,\n})\n</code></pre>\n<ol start=\"2\">\n<li>使用类型注解进行检查（TS 专属）</li>\n</ol>\n<p>第二种方式是按照 TS 的书写习惯来定义数据类型，这种情况下需要遵循 TypeScript 的类型规范，比如字符串是 string，而不是 String。</p>\n<pre><code class=\"language-ts\">// 导入 defineProps 组件\nimport { defineProps } from 'vue'\n\n// 对象类型接口\ninterface UserInfo {\n  id: number\n  age: number\n}\n\n// 定义 props\ndefineProps&lt;{\n  name: string\n  phoneNumber: number\n  userInfo: UserInfo\n  tags: string[]\n}&gt;()\n</code></pre>\n<p>在此之前，使用第二种方法，是无法指定默认值的（在当时的 RFC 的文档里也有说明无法指定）。</p>\n<p>如今，这个新的 withDefaults API 可以让你在使用 TS 类型系统时，也可以指定 props 的默认值。</p>\n<p>它接收两个入参：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">props</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">通过 defineProps 传入的 props</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">defaultValues</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">根据 props 的 key 传入默认值</td>\n</tr>\n</tbody>\n</table>\n<p>可能缺乏一些官方描述，还是看参考用法可能更直观：</p>\n<pre><code class=\"language-ts\">import { defineProps, withDefaults } from 'vue'\n\nwithDefaults(defineProps&lt;{\n  size?: number\n  labels?: string[]\n}&gt;(), {\n  size: 3,\n  labels: () =&gt; ['default label']\n})\n</code></pre>\n<h2>顶级 await 的支持</h2>\n<p>不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup 。</p>\n<pre><code class=\"language-html\">&lt;script setup lang=&quot;ts&quot;&gt;\n  const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())\n&lt;/script&gt;\n</code></pre>\n<p>它转换成标准组件的写法就是：</p>\n<pre><code class=\"language-html\">&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent, withAsyncContext } from 'vue'\n\nexport default defineComponent({\n  async setup() {\n    const post = await withAsyncContext(\n      fetch(`/api/post/1`).then((r) =&gt; r.json())\n    )\n\n    return {\n      post\n    }\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<h2>参考资料</h2>\n<p>以上所有的资料都来自于尤大在 PR 227 的评论通告……</p>\n<p>传送门：<a href=\"https://github.com/vuejs/rfcs/pull/227#issuecomment-870105222\">&lt;script setup&gt; Finalization</a></p>\n<p>好隐蔽的说，而且原来的 RFC 仓库的文档也删除了，换了新的文档也是找了好久才翻到新的，本文先根据尤大的通告做一波简单的说明，后续将会详细更新到 <a href=\"https://vue3.chengpeiquan.com/\">Vue3.0学习教程与实战案例</a> 里。</p>\n"
}