{
  "title": "聊一聊Vue3.0的script-setup 以及全新的props/emits专属API",
  "desc": "今天想聊一聊 Vue 3.0 的 script-setup，以及目前三个很少被提及到的 API —— defineProps 、 defineEmit 和 useContext。截止到我撰写本文，它们在 Vue 3.0 的官网都还没有相关的用法说明，因为目前还属于实验性的新特性，什么时候会并入正式轨道，时间上还不清楚，但事实上在项目里已经可以使用起来了，自己体验了一段时间，真的爽！！！",
  "keywords": "script setup,vue 3.0 script setup,vue3 script setup,script setup prop,script setup emit,defineProps,vue 3.0 defineProps,vue defineProps,vue3 defineProps,prop defineProps,setup defineProps,defineEmit,vue 3.0 defineEmit,vue defineEmit,vue3 defineEmit,emit defineEmit,setup defineEmit,useContext,vue 3.0 useContext,vue useContext,vue3 useContext,setup useContext",
  "date": "2021-03-05 08:48:13",
  "cover": "http://cdn.chengpeiquan.com/img/2021/02/20210305211036.jpg?x-oss-process=image/interlace,1",
  "categories": [
    "tech"
  ],
  "repo": "https://github.com/chengpeiquan/learning-vue3",
  "id": "vue3-script-setup",
  "type": "article",
  "author": {
    "name": "chengpeiquan",
    "email": "chengpeiquan@chengpeiquan.com",
    "link": "https://chengpeiquan.com"
  },
  "shortDate": "2021-03-05",
  "content": "<p>[[toc]]</p>\n<blockquote>\n<p>2021-07-05：由于版本更新，本文部分内容已有过期，最新的相关内容请阅读：<a href=\"https://chengpeiquan.com/article/vue3-script-setup-finalization.html\">Vue3.0最新动态：script-setup定稿 部分实验性API将弃用</a></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>2021-03-21：本文已同步到 <a href=\"https://vue3.chengpeiquan.com/efficient.html\">高效开发 - Vue3.0 学习教程与实战案例</a> 一章，可直接看专题文档了解更多。</p>\n</blockquote>\n<p>今天想聊一聊 Vue 3.0 的 script-setup，以及目前三个很少被提及到的 API —— defineProps 、 defineEmit 和 useContext。</p>\n<p>截止到我撰写本文，它们在 Vue 3.0 的官网都还没有相关的用法说明，<strong>因为目前还属于实验性的新特性</strong>，什么时候会并入正式轨道，时间上还不清楚，但事实上在项目里已经可以使用起来了，自己体验了一段时间，真的爽！！！</p>\n<p>目前在社区讨论方面，script-setup 的知名度还是可以的，但是对应的另外 3 个专属 API 还是比较默默无名，这说明什么？看热闹的人多，实际体验的人少。</p>\n<p>很多人应该还只是处于单纯知道 script-setup 对于原来的 setup 起到什么样的便利性，但一旦哪天真的想用起来，会发现不知道 props 怎么用，不知道 emit 怎么用，用法完全变了，还一时半会搜不到文档，关键时刻被卡住（这一点在 stackoverflow 上的问题咨询体现的比较明显），这也是我想写一写这篇文章的目的，提前科普这几个新特性。</p>\n<blockquote>\n<p><br>在阅读这篇文章之前，需要对 Vue 3.0 的 setup 函数有一定的了解，如果还处于完全没有接触过的阶段，请先抽点时间阅读 <a href=\"https://vue3.chengpeiquan.com/component.html\">单组件的编写 - Vue3.0 学习教程与实战案例</a> 。<br> &gt;<br>另外，根据 vue-next 的 <a href=\"https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md\">changelog</a> ，记得先把 vue 和 @vue/compiler-sfc 这两个依赖都升级到 v3.0.4 版本或以上（这两个依赖必须保持同样的版本号，我自己是在目前最新的 v3.0.7 版本下跑通了所有 API，版本太低会报错，因为旧版本还没有包含更新的内容）<br></p>\n</blockquote>\n<p>本文会划分为四个部分：</p>\n<ol>\n<li>\n<p>讲一讲 script-setup</p>\n</li>\n<li>\n<p>回顾一下 props 和 emits</p>\n</li>\n<li>\n<p>讲一讲 defineProps 和 defineEmit</p>\n</li>\n<li>\n<p>讲一讲 useContext</p>\n</li>\n</ol>\n<p>通过这几个维度来讲一讲这个便捷版 setup 的用法和需要注意的问题。</p>\n<h2>什么是 script-setup</h2>\n<p>在 Vue 3.0 的 .vue 组件里，标准的 setup 用法，默认的 SFC 规范里（注：SFC，即 Single-File Component，<code>.vue</code> 单组件）要求，在 setup 里面定义的数据如果需要在 template 使用，都需要 return 出来，如果你使用的是 TypeScript ，还需要借助 defineComponent 来帮助你对类型的自动推导。</p>\n<pre><code class=\"language-html\">&lt;!-- 标准组件格式 --&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n  import { defineComponent } from 'vue'\n\n  export default defineComponent({\n    setup() {\n      // 要给 template 用的数据需要 return 出来才可以\n      return {}\n    },\n  })\n&lt;/script&gt;\n</code></pre>\n<p>关于 setup 和 defineComponent 的说明和用法，可以查阅我以前写的 <a href=\"https://vue3.chengpeiquan.com/component.html#%E5%85%A8%E6%96%B0%E7%9A%84-setup-%E5%87%BD%E6%95%B0-new\">全新的 setup 函数</a> 。</p>\n<p>而 script-setup 的推出是为了让熟悉 3.0 的用户可以更高效率的开发组件，减少一些心智负担，只需要给 script 标签添加一个 setup 属性，那么整个 script 就直接会变成 setup 函数，所有顶级变量、函数，均会自动暴露给模板使用（无需再一个个 return 了）。</p>\n<p>Vue 会通过单组件编译器，在编译的时候将其处理回标准组件，所以目前这个方案只适合用 <code>.vue</code> 文件写的工程化项目。</p>\n<pre><code class=\"language-html\">&lt;!-- 使用 script-setup 格式 --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\n  // ...\n&lt;/script&gt;\n</code></pre>\n<p>对，就是这样，代码量瞬间大幅度减少……</p>\n<p>而组件的挂载，在原来的写法是需要 import 后再放到 components 里才能够启用：</p>\n<pre><code class=\"language-html\">&lt;!-- 标准组件格式 --&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n  import { defineComponent } from 'vue'\n\n  // 需要先导入组件\n  import Header from '@cp/Header.vue'\n\n  export default defineComponent({\n    // 需要通过 components 才能启用子组件\n    components: {\n      Header,\n    },\n    setup() {\n      // ...\n    },\n  })\n&lt;/script&gt;\n</code></pre>\n<p>在 script-setup 模式下，只需要导入组件即可，编译器会自动识别并启用。</p>\n<pre><code class=\"language-html\">&lt;!-- 使用 script-setup 格式 --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\n  import Header from '@cp/Header.vue'\n&lt;/script&gt;\n</code></pre>\n<p>其他的变量、函数，以及 onMounted 等生命周期，还有像 watch 、 computed 等监听/计算功能，都跟原来一样定义就可以了，没有太大的区别。</p>\n<p>区别比较大的还是 props / emits 的定义和调用，由于在 export 组件的时候没有了对象式选项，setup 也没有了函数入参，标准组件的用法无法直接迁移到 script-setup ，因此针对该模式， Vue 3.0 单独推出了三个专属的 API：defineProps 、 defineEmit 和 useContext 。</p>\n<p>在了解它俩之前，想先给大家回顾下什么是 props 和 emits ，已经了解熟悉它们的同学可以直接跳去本文 <a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-defineprops-%E5%92%8C-defineemit\">什么是 defineProps 和 defineEmit</a> 部分。</p>\n<h2>什么是 props 和 emits</h2>\n<p>通常我们为了避免一个页面（父组件）写的又长又臭，会根据布局/功能模块，把页面切割为不同的小模块（子组件），最后再像搭积木一样把它搭回来，完成我们的作品，我画了一个示例图，就是下面这样子：</p>\n<p><img src=\"http://cdn.chengpeiquan.com/img/2021/01/20210303180727.png\" alt=\"每一个“积木”都是一个组件\"></p>\n<p>比如上面是一个 home.vue , 它包含了 Header.vue / Footer.vue / Content.vue / Sidebar.vue 等子组件，如果此时页面上有一个公共的数据，有多个子组件都需要用到的话，就没有必要在诸如 Content / Sidebar 里分别获取或者定义了，而是在父组件 home 里面处理好后，传递给子组件使用。</p>\n<p>props 就是在这种情况下用于父组件向子组件传递数据，而 emits 则是让子组件可以向父组件发起通信。</p>\n<p>在 home.vue 定义了一个数据和方法之后，传递给子组件 Content.vue ：</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;content :name=&quot;name&quot; @change-name=&quot;changeName&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script lang=&quot;ts&quot;&gt;\n  import { defineComponent, ref } from 'vue'\n  import Content from '@cp/Content.vue'\n\n  export default defineComponent({\n    components: {\n      Content,\n    },\n    setup() {\n      const name = ref&lt;string&gt;('Petter')\n\n      const changeName = (): void =&gt; {\n        name.value = 'Tom'\n      }\n\n      return {\n        name,\n        changeName,\n      }\n    },\n  })\n&lt;/script&gt;\n</code></pre>\n<p>子组件通过 prop 来接收 name 数据，通过 emit 来接收和提交名字的变更方法 changeName ：</p>\n<pre><code class=\"language-html\">&lt;script lang=&quot;ts&quot;&gt;\n  import { defineComponent } from 'vue'\n\n  export default defineComponent({\n    props: ['name'],\n    emits: ['changeName'],\n    setup(props, { emit }) {\n      setTimeout(() =&gt; {\n        emit('changeName', 'Tom')\n      }, 1000)\n    },\n  })\n&lt;/script&gt;\n</code></pre>\n<p>当然，这里不是想说 props 和 emits 怎么用，关于 props 和 emits 的定义和具体用法，在 <a href=\"https://vue3.chengpeiquan.com/communication.html#props-emits\">props / emits</a> 一节已有详细的总结和案例，这篇文章里就不再展开更多说明啦！</p>\n<h2>什么是 defineProps 和 defineEmit</h2>\n<p>回来说这两个 API ，顾名思义， defineProps 一看就知道是用来定义 props 的，而 defineEmit 则是用来定义 emits 的，那么它俩跟上面提到的 props / emits 有什么区别？</p>\n<p>在你的项目 <code>node_modules\\@vue\\runtime-core\\dist\\runtime-core.d.ts</code> 里，有一段针对该 API 的注释（不要问我怎么找到这里的，我只能跟你说我用的 VSCode …）：</p>\n<pre><code class=\"language-ts\">/**\n * Compile-time-only helper used for declaring props inside `&lt;script setup&gt;`.\n * This is stripped away in the compiled code and should never be actually\n * called at runtime.\n */\n</code></pre>\n<p>很清晰的解释了它们的使用限制，只能用于 script-setup 。</p>\n<p>那么我们来看下用便捷版 setup 写法之后，父组件长什么样：</p>\n<pre><code class=\"language-html\">&lt;!-- 这是父组件，template 下发了 prop 和 emit --&gt;\n&lt;template&gt;\n  &lt;Child :name=&quot;name&quot; @change-name=&quot;changeName&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\n  import { ref } from 'vue'\n  import Child from '@cp/Child.vue'\n\n  const name = ref&lt;string&gt;('Petter')\n\n  const changeName = (): void =&gt; {\n    name.value = 'Tom'\n  }\n&lt;/script&gt;\n</code></pre>\n<p>有没有瞬间清爽百倍的感觉！！！</p>\n<p>在 script-setup 的写法里，所有数据都是默认 <code>return</code> 的，子组件也无需通过 <code>components</code> 选项进行挂载了，默认导入即生效，在编码过程中，可以大大的提高开发效率。</p>\n<blockquote>\n<p>所以疑问就来了，父组件是爽了，那么子组件呢？整个 script 都变成了一个大的 setup function ，没有了组件选项，也没有了 setup 入参，如何获取父组件传下来的 props 和 emits 呢？</p>\n</blockquote>\n<p>所以，这两个新的 API ，就是在 script-setup 里帮助子组件拿到父级传过来的 props 和 emits 。</p>\n<blockquote>\n<p>注：以下所有的 JS / TS 部分，如果没有特别说明，都是指写在 <code>&lt;script setup&gt;</code> 里</p>\n</blockquote>\n<h2>defineProps</h2>\n<p>defineProps 是一个方法，内部返回一个对象，也就是挂载到这个组件上的所有 props ，它和普通的 props 用法一样，如果不指定为 prop， 则传下来的属性会被放到 attrs 那边去。</p>\n<h3>基础用法</h3>\n<p>所以，如果只是单纯在 template 里使用，那么其实就这么简单定义就可以了：</p>\n<pre><code class=\"language-js\">import { defineProps } from 'vue'\n\ndefineProps(['name', 'userInfo', 'tags'])\n</code></pre>\n<p>使用 <code>string[]</code> 数组作为入参，把 prop 的名称作为数组的 item 传给 defineProps 就可以了。</p>\n<blockquote>\n<p>记得从 vue 导入 defineProps 噢，下面的代码就不重复 import 啦！！！</p>\n</blockquote>\n<p>如果 script 里的方法要拿到 props 的值，你也可以使用字面量定义：</p>\n<pre><code class=\"language-ts\">const props = defineProps(['name', 'userInfo', 'tags'])\n\nconsole.log(props.name)\n</code></pre>\n<p>但在作为一个 Vue 老玩家，都清楚不显性的指定 prop 类型的话，很容易在协作中引起程序报错，那么应该如何对每个 prop 进行类型检查呢？</p>\n<p>有两种方式来处理类型定义。</p>\n<h3>通过构造函数进行检查</h3>\n<p>这是第一种方式：使用 JavaScript 原生构造函数进行类型规定。</p>\n<p>也就是跟我们平时定义 prop 类型时一样， Vue 会通过 instanceof 来进行 <a href=\"https://v3.cn.vuejs.org/guide/component-props.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5\">类型检查</a> 。</p>\n<p>使用这种方法，需要通过一个 “对象” 入参来传递给 defineProps，比如：</p>\n<pre><code class=\"language-ts\">defineProps({\n  name: String,\n  userInfo: Object,\n  tags: Array,\n})\n</code></pre>\n<p>所有原来 props 具备的校验机制，都可以适用，比如你除了要限制类型外，还想指定 name 是可选，并且带有一个默认值：</p>\n<pre><code class=\"language-ts\">defineProps({\n  name: {\n    type: String,\n    required: false,\n    default: 'Petter',\n  },\n  userInfo: Object,\n  tags: Array,\n})\n</code></pre>\n<p>更多的 props 校验机制，可以点击 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E5%B8%A6%E6%9C%89%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6%E7%9A%84-props\">带有类型限制的 props</a> 和 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E5%8F%AF%E9%80%89%E4%BB%A5%E5%8F%8A%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84-props\">可选以及带有默认值的 props</a> 了解更多。</p>\n<h3>使用类型注解进行检查</h3>\n<p>这是第二种方式：使用 TypeScript 的类型注解。</p>\n<p>和 ref 等 API 的用法一样，defineProps 也是可以使用尖括号 &lt;&gt; 来包裹类型定义，紧跟在 API 后面，另外，由于 defineProps 返回的是一个对象（因为 props 本身是一个对象），所以尖括号里面的类型还要用大括号包裹，通过 <code>key: value</code> 的键值对形式表示，如：</p>\n<pre><code class=\"language-ts\">defineProps&lt;{ name: string }&gt;()\n</code></pre>\n<p>注意到了吗？这里使用的类型，和第一种方法提到的指定类型时是不一样的，在这里，不再使用构造函数校验，而是需要遵循使用 TypeScript 的类型，比如字符串是 string，而不是 String。</p>\n<p>如果有多个 prop ，就跟写 interface 一样：</p>\n<pre><code class=\"language-ts\">defineProps&lt;{\n  name: string\n  phoneNumber: number\n  userInfo: object\n  tags: string[]\n}&gt;()\n</code></pre>\n<p>其中，举例里的 userInfo 是一个对象，你可以简单的指定为 object，也可以先定义好它对应的类型，再进行指定：</p>\n<pre><code class=\"language-ts\">interface UserInfo {\n  id: number\n  age: number\n}\n\ndefineProps&lt;{\n  name: string\n  userInfo: UserInfo\n}&gt;()\n</code></pre>\n<p>如果你想对某个数据设置为可选，也是遵循 TS 规范，通过英文问号 <code>?</code> 来允许可选：</p>\n<pre><code class=\"language-ts\">// name 是可选\ndefineProps&lt;{\n  name?: string\n  tags: string[]\n}&gt;()\n</code></pre>\n<p>如果你想设置可选参数的默认值，这个暂时不支持，不能跟 TS 一样指定默认值，在 RFC 的文档里也有说明目前无法指定。</p>\n<blockquote>\n<p>Unresolved questions: Providing props default values when using type-only props declaration.</p>\n</blockquote>\n<p>不过如果你确实需要默认指定，并且无需保留响应式的话，我自己测试是可以按照 ES6 的参数默认值方法指定：</p>\n<pre><code class=\"language-ts\">const { name = 'Petter' } = defineProps&lt;{\n  name?: string\n  tags: string[]\n}&gt;()\n</code></pre>\n<p>这样如果传入了 name 则按传入的数据，否则就按默认值，但是，有个但是，就是这样 name 就会失去响应性（因为响应式数据被解构后会变回普通数据），请注意这一点！</p>\n<blockquote>\n<p>需要强调的一点是：这两种校验方式只能二选一，否则会引起程序报错</p>\n</blockquote>\n<h2>defineEmit</h2>\n<p>defineEmit 也是一个方法，它接受的入参格式和标准组件的要求是一致的。</p>\n<blockquote>\n<p>注意：defineProps 是复数结尾，带有 s，defineEmit 没有！</p>\n</blockquote>\n<p>由于 emit 并非提供给模板直接读取，所以需要通过字面量来定义 emits，最基础的用法也是传递一个 string[] 数组进来，把每个 emit 的名称作为数组的 item 。</p>\n<pre><code class=\"language-ts\">// 获取 emit\nconst emit = defineEmit(['chang-name'])\n\n// 调用 emit\nemit('chang-name', 'Tom')\n</code></pre>\n<p>由于 defineEmit 的用法和原来的 emits 选项差别不大，这里也不重复说明更多的诸如校验之类的用法了，可以查看 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E6%8E%A5%E6%94%B6-emits\">接收 emits</a> 一节了解更多。</p>\n<h2>useContext</h2>\n<p>在标准组件写法里，setup 函数默认支持两个入参：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">props</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">由父组件传递下来的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">context</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">组件的执行上下文</td>\n</tr>\n</tbody>\n</table>\n<p>这里的第二个参数 context，在 script-setup 写法里，就需要通过 useContext 来获取，一样的，记得先导入依赖：</p>\n<pre><code class=\"language-ts\">// 导入 useContext 组件\nimport { useContext } from 'vue'\n\n// 获取 context\nconst ctx = useContext()\n\n// 打印 attrs\nconsole.log(ctx.attrs)\n</code></pre>\n<p>你也可以对它进行解构，直接获取到内部的数据：</p>\n<pre><code class=\"language-ts\">// 直接获取 attrs\nconst { attrs } = useContext()\n</code></pre>\n<p>对于 context 的使用和注意事项，如果不了解的话，可以在 <a href=\"https://vue3.chengpeiquan.com/component.html#setup-%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8\">setup 的参数使用</a> 了解更多。</p>\n<h2>参考资料</h2>\n<p>以上所有的资料都来自于 Vue 的 rfcs 仓库，原文传送门：<a href=\"https://github.com/vuejs/rfcs/blob/script-setup-2/active-rfcs/0000-script-setup.md\">script-setup - vuejs/rfcs</a> 。</p>\n<p>除了看英文说明适当做了翻译之外，大部分坑点都是自己在 DEMO 里运行出来总结的，后面如果有什么变动的话，建议以官网文档的正式版为准，我也会留意他们正式发布后的变化进行内容更新。</p>\n<h2>结语</h2>\n<p>目前在运行项目的时候，控制台会有提醒：</p>\n<pre><code class=\"language-bash\">[@vue/compiler-sfc] &lt;script setup&gt; is still an experimental proposal.\nFollow its status at https://github.com/vuejs/rfcs/pull/227.\n\n[@vue/compiler-sfc] When using experimental features,\nit is recommended to pin your vue dependencies to exact versions to avoid breakage.\n</code></pre>\n<p>告知 script setup 当前仍然是个实验性的新特性，还没有作为正式特性发布，后面会不会有变化还不好说，本文仅作为目前有用到这个新特性的同学参考。</p>\n<p>更多关于 Vue 3.0 的起步教程，可以在 <a href=\"https://vue3.chengpeiquan.com\">Vue3.0 学习教程与实战案例</a> 了解，稍后有时间我也会把这部分内容一起合并进去。</p>\n"
}