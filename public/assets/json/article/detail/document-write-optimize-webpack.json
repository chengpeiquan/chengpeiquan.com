{
  "title": "针对document.write渲染的优化方案（适用webpack按需加载）",
  "desc": "write方法去渲染html，更多情况是适合手写页面的年代，现在前端开发都是通过node+webpack工程化打包，那么遇到必须write又不想write的情况应该怎么办？最近刚好对手里的一个项目做了渲染优化，在这里顺便做个总结，讲一下对`document.write`渲染html的一个优化思路，可以结合到MVVM框架（如Vue.js）里去使用。",
  "keywords": "document.write渲染优化,vue document.write",
  "date": "2018-12-16 00:34:00",
  "cover": "http://cdn.chengpeiquan.com/img/2018/12/1.jpg?x-oss-process=image/interlace,1",
  "categories": [
    "tech"
  ],
  "id": "document-write-optimize-webpack",
  "type": "article",
  "author": {
    "name": "chengpeiquan",
    "email": "chengpeiquan@chengpeiquan.com",
    "link": "https://chengpeiquan.com"
  },
  "shortDate": "2018-12-16",
  "content": "<p>[[toc]]</p>\n<p>参与过 discuz 相关业务开发的同学应该都知道，dz 论坛有一套自带的 api 系统叫数据调用（后台-门户-模块管理-数据调用），对于论坛运营同学来说，可以将模块的外部调用作为广告位数据源、或者引用到专题页面去展示论坛内容，很受运营的喜爱。</p>\n<p>但这套系统有个问题就是，所有的渲染方式都是通过<code>document.write</code>去抓取模板语法生成的 html 数据，而<code>document.write</code>我们都知道，在现代化的前端开发里是越来越排斥这个方法，因为会引起性能问题，影响网页的渲染速度，write 的越多，渲染越慢。</p>\n<p>而且 write 方法去渲染 html，更多情况是适合手写页面的年代，现在前端开发都是通过 node+webpack 工程化打包，那么遇到必须 write 又不想 write 的情况应该怎么办？最近刚好对手里的一个项目做了渲染优化，在这里顺便做个总结，讲一下对<code>document.write</code>渲染 html 的一个优化思路，可以结合到 MVVM 框架（如 Vue.js）里去使用。</p>\n<h2>痛点分析</h2>\n<p>一个多元化的专题里面，会有轮播图、帖子列表、帖子排行榜等不同的模块，而传统的数据调用渲染方式，注定了一个模块只能一个调用，于是一个页面下来会有 N 个数据调用，也就是有 N 个<code>document.write</code>。</p>\n<h3>回顾传统的方法</h3>\n<p>通过 html 模板配置数据调用，在 html 里引入数据调用，会通过 write 去渲染 html，如果页面有太多 write，渲染会卡顿严重。</p>\n<p>相关模板如下，传统的模板就是 html 结构长什么样，模板结构就长什么样：</p>\n<pre><code class=\"language-javascript\">&lt;ul&gt;\n  [loop]\n  &lt;li&gt;\n    &lt;a href=&quot;{url}&quot;&gt;\n      &lt;img src=&quot;{pic}&quot;&gt;\n      &lt;p&gt;{title}&lt;/p&gt;\n      &lt;p&gt;{dateline}&lt;/p&gt;\n    &lt;/a&gt;\n  &lt;/li&gt;\n  [/loop]\n&lt;/ul&gt;\n</code></pre>\n<h3>曾经尝试的方法</h3>\n<p>如果说直接去 wirte 出 html dom 会严重卡顿，那我是不是可以 write 出 object，先通过 js 处理完数据再一次性渲染？毕竟 wirte 出来的脚本是可以运行的！</p>\n<p>答案当然是可以！！！并且自己亲测有效！！！</p>\n<p>相关模板如下，把模板写成 js，把数据源定义成一个 json array：</p>\n<pre><code class=\"language-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\nvar articleData = [\n  [index=1]\n  {\n    &quot;tid&quot;: &quot;{id}&quot;,\n    &quot;subject&quot;: &quot;{title}&quot;,\n    &quot;date&quot;: &quot;{dateline}&quot;\n  }\n  [/index]\n  [loop]\n  ,{\n    &quot;tid&quot;: &quot;{id}&quot;,\n    &quot;subject&quot;: &quot;{title}&quot;,\n    &quot;date&quot;: &quot;{dateline}&quot;\n  }\n  [/loop]\n];\n&lt;/script&gt;\n</code></pre>\n<p>然而！！！但是！！！因为最终负责维护数据源（也就是负责推送或者抓取的人）是运营同学，他们并不清楚 js 或者 json 需要注意的问题，通过 object 格式配置数据调用模板，又会在运营过程中，因为反斜杆，引号等问题导致数据报错，整个页面渲染崩溃。</p>\n<p>而且还有一个问题就是，现在用 node+webpack 来做开发的话，这种方式依然必须用传统的渲染方法，也就是在 entry 的 index.html 里，引入这个数据调用才行，无法通过构建打包然后按需加载！！！</p>\n<h2>优化思路</h2>\n<p>回顾了痛点，我们梳理一下我们想要的东西：</p>\n<p>1、渲染的时候不要 write，更不要直接 write 出好多 DOM 去导致卡顿</p>\n<p>2、开发阶段不要去修改 entry 的 index.html，想全部由 webpack 构建生成</p>\n<p>3、最终渲染的时候可以按需加载，不要有多少数据源就在打开页面的时候全部加载完</p>\n<p>目的理清楚了，解决方案是不是越来越清晰！！！不错，就是 ajax！</p>\n<p>我以一个基于 Vue-CLI 的案例来直观的表达我的处理思路和方式吧！（这里有一个地方需要注意，就是通过这种方式来获取数据调用内容源的时候，不能跨域，除非你们服务端配置了允许跨域，否则专题最终都得传到论坛域名下）。</p>\n<h2>discuz 数据调用模板</h2>\n<p>这是写在数据调用的模板里的模板代码，具体语法参照模板说明，但是 html 结构无需遵循业务需要，只需要最简单的 html 标签和 className 就可以了，目的是通过 className 去获取对应标签里的文本。</p>\n<p>这里是以抓取论坛帖子为例子，抓取了帖子 id、帖子标题、发布时间和缩略图：</p>\n<pre><code class=\"language-javascript\">&lt;ul&gt;\n  [loop]\n    &lt;li&gt;\n      &lt;span class=&quot;tid&quot;&gt;{id}&lt;/span&gt;\n      &lt;span class=&quot;subject&quot;&gt;{title}&lt;/span&gt;\n      &lt;span class=&quot;date&quot;&gt;{dateline}&lt;/span&gt;\n      &lt;img class=&quot;cover&quot; src=&quot;{pic}&quot;&gt;\n    &lt;/li&gt;\n  [/loop]\n&lt;/ul&gt;\n</code></pre>\n<h2>Vue 组件模板</h2>\n<p>写在 Vue 组件的 template 里，这是一个包含了链接、封面、标题、发布时间的文章列表。</p>\n<pre><code class=\"language-javascript\">&lt;ul class=&quot;article-list&quot;&gt;\n  &lt;li class=&quot;item&quot; v-for=&quot;item in articleList&quot;&gt;\n    &lt;router-link :to=&quot;`/article/${item.tid}`&quot; &gt;\n      &lt;div class=&quot;cover&quot;&gt;\n        &lt;img :src=&quot;item.cover&quot;&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;subject&quot;&gt;{{ item.subject }}&lt;/div&gt;\n      &lt;div class=&quot;date&quot;&gt;{{ item.date }}&lt;/div&gt;\n    &lt;/router-link&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h2>Vue 数据格式</h2>\n<p>在 Vue 组件 data 里的一个数据，最终文章列表的数据源是一个 JSON 数组：</p>\n<pre><code class=\"language-javascript\">articleList: [\n  {\n    tid: '123',\n    subject: '文章的标题111',\n    date: '2018-11-11',\n    cover: 'https://chengpeiquan.com/img/cover1.jpg?x-oss-process=image/interlace,1/resize,w_750',\n  },\n  {\n    tid: '456',\n    subject: '文章的标题222',\n    date: '2018-12-12',\n    cover: 'https://chengpeiquan.com/img/cover2.jpg?x-oss-process=image/interlace,1/resize,w_750',\n  },\n]\n</code></pre>\n<h2>Vue 数据请求方法</h2>\n<p>请求数据如我们前面说的，通过 ajax 去获取，避开<code>document.write</code>带来的性能问题，以下是基于 axios 的请求演示，请根据业务场景调整。</p>\n<pre><code class=\"language-javascript\">this.$ajax({\n  method: 'get',\n  url: '/api.php',\n  params: {\n    mod: 'js',\n    bid: 123,\n  },\n})\n  .then((response) =&gt; {\n    // 把数据调用返回的数据进行格式化\n    const DATA = response.data.slice(16, -3).replace(/\\\\n|\\t/g, '')\n\n    // 缓存格式化后的html代码，写入一个临时的DOM里\n    const NEW_DIV = document.createElement('div')\n    NEW_DIV.innerHTML = DATA\n\n    // 提取需要的标签内容，转为JSON格式\n    const RESULT = []\n    const LIST = NEW_DIV.querySelectorAll('li')\n    LIST.forEach((item, index) =&gt; {\n      // 遍历期间都先统一缓存结果\n      const RESULT_ITEM = {}\n      RESULT_ITEM['tid'] = item.querySelector('.tid').innerText\n      RESULT_ITEM['subject'] = item.querySelector('.subject').innerText\n      RESULT_ITEM['date'] = item.querySelector('.date').innerText\n      RESULT_ITEM['cover'] = item.querySelector('img').src\n      RESULT.push(item)\n\n      // 遍历结束再统一生成虚拟DOM\n      if (index === LIST.length - 1) {\n        this.articleList = RESULT\n      }\n    })\n  })\n  .catch((error) =&gt; {\n    console.log(error)\n  })\n</code></pre>\n"
}